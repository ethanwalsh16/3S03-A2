\documentclass{article}
\usepackage[english]{babel}
\usepackage[letterpaper,top=2cm,bottom=2cm,left=2cm,right=2cm,marginparwidth=1.75cm]{geometry}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{float}
\usepackage{tikz}
\usepackage{amsfonts}
\usepackage{tabularx}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{listings}
\lstset{
    language=Java,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    stringstyle=\color{green!50!black},
    commentstyle=\color{gray},
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    frame=single,
    tabsize=4,
    showstringspaces=false
}

\setlength{\parindent}{0pt}

\title{3S03 Assignment 3}
\author{Ethan Walsh - 400383566 - walshe11 \\ Ahsan Muzammil - 400455916 - muzammia}

\begin{document}
\maketitle
\section*{Question 1}

\begin{table}[h]
    \renewcommand{\arraystretch}{1.2}
    \setlength{\extrarowheight}{2pt} 
    \centering
    \begin{tabularx}{\textwidth}{ |X|X| } 
        \hline
        \textbf{Class Objectives} & Ensure that all methods and constructors meet expected behaviour. This includes usual operations such as getting and setting the direction, speed, and its components (speedX and speedY). Boundary values and unexpected inputs should be tested for a complete and robust test suite. \\ 
        \hline
        \textbf{Inspection/Review Requirements} & May require inspection in order to understand the interface implementations - for example, how the components (speedX and speedY) are calculated. This will give the test developers a better idea of what to target, taking advantage of any vulnerabilities that can be seen during white box testing. \\ 
        \hline
        \textbf{Specification-Based Testing Objectives} & Assuming this is more aligned with the game's function (reversing direction when at a boundary, speedY remains the same and speedX is multiplied by -1 when colliding with side walls). \\ 
        \hline
        \textbf{Implementation-Based Testing Objectives} & May be helpful for components calculations (cosine etc.) \\ 
        \hline
        \textbf{Interaction-Based Testing Objectives} & interaction between reverse, as well as reverseX and reverseY may be worth testing (as it's not immmediately clear why all 3 are needed, except maybe for corner hits when both components are reversed). \\ 
        \hline
    \end{tabularx}
\end{table}

General planning ideas:

- For speed, input partitioning (negative max, negative integer, zero, positive integer, positive max)
- For direction, testing overflow (going from 359 back to zero) and standard angles

\section*{Question 2}

Contract - weakest precondition, strongest postcondition for all methods. \\

Class invariant:
\begin{itemize}
    \item \( \text{speed} \in \mathbb{Z} \) (speed is always non-negative)
    \item \( \text{direction} \in [0,360) \wedge \text{direction} \in \mathbb{Z} \) (direction is always a valid angle)
    \item \( \text{speedX} = \text{speed} \cdot \cos(\text{direction}) \)
    \item \( \text{speedY} = \text{speed} \cdot \sin(\text{direction}) \)
\end{itemize}


\subsection*{\texttt{public Velocity()}}
\textbf{Pre-condition:}
\begin{itemize}
    \item No input constraints (default constructor).
\end{itemize}

\textbf{Post-condition:}
\begin{itemize}
    \item \( \text{speed} = 0 \), \( \text{speedX} = 0 \), \( \text{speedY} = 0 \).
    \item \( \text{direction} \) is initialized to a default value (e.g., 0).
\end{itemize}


\subsection*{\texttt{public Velocity(Speed speed, Direction direction)}}
\textbf{Pre-condition:}
\begin{itemize}
    \item \( \text{speed} \in \mathbb{Z} \)
    \item \( \text{direction} \in \mathbb{Z} \wedge \text{direction} \in [0,360) \)
\end{itemize}

\textbf{Post-condition:}
\begin{itemize}
    \item \( \text{this.speed} = \text{speed} \)
    \item \( \text{this.direction} = \text{direction} \)
    \item \( \text{this.speedX} = \text{speed} \cdot \cos(\text{direction}) \)
    \item \( \text{this.speedY} = \text{speed} \cdot \sin(\text{direction}) \)
\end{itemize}


\subsection*{\texttt{public Speed getSpeed()}}
\textbf{Pre-condition:}
\begin{itemize}
    \item \( \text{speed} \in \mathbb{Z} \).
\end{itemize}

\textbf{Post-condition:}
\begin{itemize}
    \item Returns \( \text{speed} \).
    \item \( \text{this.speed} = \frac{\text{speedX}}{\cos(\text{direction})} \).
    \item \( \text{this.speed} = \frac{\text{speedY}}{\sin(\text{direction})} \).
\end{itemize}


\subsection*{\texttt{public Speed getSpeedX()}}
\textbf{Pre-condition:}
\begin{itemize}
    \item \( \text{speedX} \in \mathbb{Z} \).
\end{itemize}

\textbf{Post-condition:}
\begin{itemize}
    \item Returns \( \text{speedX} \text{ and this.speedX} = \text{speed} \cdot \cos(\text{direction}) \).
\end{itemize}


\subsection*{\texttt{public Speed getSpeedY()}}
\textbf{Pre-condition:}
\begin{itemize}
    \item \( \text{speedY} \in \mathbb{Z} \).
\end{itemize}

\textbf{Post-condition:}
\begin{itemize}
    \item Returns \( \text{speedY} \text{ and this.speedY} = \text{speed} \cdot \sin(\text{direction}) \).
\end{itemize}


\subsection*{\texttt{public Direction getDirection()}}
\textbf{Pre-condition:}
\begin{itemize}
     \item \( \text{direction} \in \mathbb{Z} \wedge \text{direction} \in [0,360) \)
\end{itemize}

\textbf{Post-condition:}
\begin{itemize}
    \item Returns \( \text{direction} \text{, this.direction} = \text{direction, and direction} \in [0,360) \wedge \text{direction} \in \mathbb{Z} \).
\end{itemize}


\subsection*{\texttt{public void setSpeed(Speed speed)}}
\textbf{Pre-condition:}
\begin{itemize}
    \item \( \text{speed} \in \mathbb{Z} \)
\end{itemize}

\textbf{Post-condition:}
\begin{itemize}
    \item \( \text{this.speed} = \text{speed} \)
    \item \( \text{this.speedX} = \text{speed} \cdot \cos(\text{direction}) \)
    \item \( \text{this.speedY} = \text{speed} \cdot \sin(\text{direction}) \)
\end{itemize}


\subsection*{\texttt{public void setDirection(Direction direction)}}
\textbf{Pre-condition:}
\begin{itemize}
     \item \( \text{direction} \in \mathbb{Z} \wedge \text{direction} \in [0,360) \)
\end{itemize}

\textbf{Post-condition:}
\begin{itemize}
    \item \( \text{this.direction} = \text{direction} \)
    \item \( \text{this.speedX} = \text{speed} \cdot \cos(\text{direction}) \)
    \item \( \text{this.speedY} = \text{speed} \cdot \sin(\text{direction}) \)
\end{itemize}


\subsection*{\texttt{public void reverse()}}
\textbf{Pre-condition:}
\begin{itemize}
    \item \( \text{speedX} \in \mathbb{Z} \).
    \item \( \text{speedY} \in \mathbb{Z} \).
    \item \( \text{direction} \in \mathbb{Z} \wedge \text{direction} \in [0,360) \)
\end{itemize}

\textbf{Post-condition:}
\begin{itemize}
    \item \( \text{this.direction} \) = \( (\text{direction} + 180) \% 360 \).
    \item \( \text{this.speedX} = \text{speed} \cdot \cos(\text{direction}) \)
    \item \( \text{this.speedY} = \text{speed} \cdot \sin(\text{direction}) \)
    \item \( \text{direction} \in [0,360) \wedge \text{direction} \in \mathbb{Z} \)
\end{itemize}

\subsection*{\texttt{public void reverseX()}}
\textbf{Pre-condition:}
\begin{itemize}
    \item \( \text{speedX} \in \mathbb{Z} \).
    \item \( \text{direction} \in \mathbb{Z} \wedge \text{direction} \in [0,360) \)
\end{itemize}

\textbf{Post-condition:}
\begin{itemize}
    \item \( \text{this.speedX} = -\text{speedX} \).
    \item \( \text{this.direction} \) = \( (180 - \text{direction}) \) \% 360.
\end{itemize}

\subsection*{\texttt{public void reverseY()}}
\textbf{Pre-condition:}
\begin{itemize}
    \item \( \text{speedY} \in \mathbb{Z} \).
    \item \( \text{direction} \in \mathbb{Z} \wedge \text{direction} \in [0,360) \)
\end{itemize}

\textbf{Post-condition:}
\begin{itemize}
    \item \( \text{this.speedY} = -\text{speedY} \).
    \item \( \text{this.direction} \) = \( (-\text{direction}) \) \% 360.
\end{itemize}

\section*{Question 3}

Informally defined set of test cases for:

setDirection (1), setSpeed (1), reverse (5), reverseX (5)

\begin{lstlisting}
    public class TestVelocity
    {
        @Test
        public void testSetDirection()
        {
            Velocity puck = new Velocity(5, 90);
            puck.setDirection(180);
            assertEquals(180, puck.getDirection());
        }

        @Test
        public void testSetSpeed()
        {
            Velocity puck = new Velocity(5, 90);
            puck.setSpeed(10);
            assertEquals(10, puck.getSpeed());
        }

        @Test
        public void testReverseWithCurrentDirectionOnXAxisOnly()
        {
            Velocity puck = new Velocity(5, 0);
            puck.reverse();
            assertEquals(180, puck.getDirection());
            
        }

        @Test
        public void testReverseWithCurrentDirectionOnYAxisOnly()
        {
            Velocity puck = new Velocity(5, 90);
            puck.reverse();
            assertEquals(270, puck.getDirection());
            
        }

        @Test
        public void testReverseWithCurrentDirectionOnDiagonalLessThan180()
        {
            Velocity puck = new Velocity(5, 45);
            puck.reverse();
            assertEquals(225, puck.getDirection());
            
        }

        @Test
        public void testReverseWithCurrentDirectionOnDiagonalGreaterThan180()
        {
            Velocity puck = new Velocity(5, 190);
            puck.reverse();
            assertEquals(10, puck.getDirection());
            
        }

        @Test
        public void testReverseWithCurrentDirectionEqualTo359()
        {
            Velocity puck = new Velocity(5, 359);
            puck.reverse();
            assertEquals(179, puck.getDirection());
            
        }
    }
\end{lstlisting}

\end{document}
